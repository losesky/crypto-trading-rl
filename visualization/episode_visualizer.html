<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RL Trading Episode Visualizer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <style>
        body { font-family: sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }
        h1, h2 { text-align: center; color: #333; }
        #controls { margin-bottom: 20px; text-align: center; padding: 10px; background-color: #fff; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        #fileInput { padding: 8px; margin-right: 10px; border: 1px solid #ddd; border-radius: 4px; }
        .chart-container { 
            width: 95%; /* Keep it responsive */
            max-width: 1200px; /* Increased max-width for larger screens */
            min-height: 450px; /* Minimum height for the chart container */
            margin: 30px auto; 
            padding: 25px; 
            background-color: #fff; 
            border-radius: 8px; 
            box-shadow: 0 0 12px rgba(0,0,0,0.1); 
            display: flex; /* Use flexbox to help center canvas if it's smaller */
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        canvas { 
            display: block; 
            max-height: 400px; /* Max height for the canvas itself, adjust as needed */
        }
        #episodeInfo { margin-top: 20px; padding: 15px; background-color: #e9e9e9; border-radius: 8px; }
        #episodeInfo p { margin: 5px 0; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #e9e9e9; }
        .action-long { color: green; }
        .action-short { color: red; }
        .action-hold { color: orange; }
    </style>
</head>
<body>
    <h1>RL Trading Episode Visualizer</h1>

    <div id="controls">
        <label for="fileInput">Select Episode JSON file(s):</label>
        <input type="file" id="fileInput" accept=".json" multiple onchange="handleFiles(this.files)">
    </div>

    <div id="visualizationArea">
        <!-- Charts and tables will be dynamically added here -->
    </div>

    <script>
        let chartObjects = {}; // To keep track of Chart.js instances

        function handleFiles(files) {
            const visualizationArea = document.getElementById('visualizationArea');
            visualizationArea.innerHTML = ''; // Clear previous visualizations
            for (const file of files) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const episodeData = JSON.parse(event.target.result);
                        displayEpisodeData(episodeData, file.name);
                    } catch (e) {
                        console.error("Error parsing JSON from file:" + file.name, e);
                        visualizationArea.innerHTML += `<p>Error loading ${file.name}: Invalid JSON format.</p>`;
                    }
                };
                reader.readAsText(file);
            }
        }

        function displayEpisodeData(data, fileName) {
            const visualizationArea = document.getElementById('visualizationArea');
            const episodeId = `episode-${fileName.replace(/[^a-zA-Z0-9]/g, '-')}`; // Create a unique ID for the episode container

            const episodeContainer = document.createElement('div');
            episodeContainer.id = episodeId;
            episodeContainer.classList.add('episode-visualization');
            episodeContainer.innerHTML = `<h2>Episode: ${fileName} (Number: ${data.episode_number})</h2>`;
            
            // Display Episode Summary
            if (data.summary) {
                const summaryDiv = document.createElement('div');
                summaryDiv.id = `summary-${episodeId}`;
                summaryDiv.classList.add('episodeInfo');
                summaryDiv.innerHTML = '<h3>Episode Summary</h3>';
                for(const key in data.summary){
                    summaryDiv.innerHTML += `<p><strong>${formatKey(key)}:</strong> ${data.summary[key]}</p>`;
                }
                episodeContainer.appendChild(summaryDiv);
            }

            // Combined Price and Capital Chart
            const priceCapitalChartContainer = document.createElement('div');
            priceCapitalChartContainer.classList.add('chart-container');
            const priceCapitalCanvasId = `priceCapitalChart-${episodeId}`;
            priceCapitalChartContainer.innerHTML = `<canvas id="${priceCapitalCanvasId}"></canvas>`;
            episodeContainer.appendChild(priceCapitalChartContainer);

            // Reward Chart
            const rewardChartContainer = document.createElement('div');
            rewardChartContainer.classList.add('chart-container');
            const rewardCanvasId = `rewardChart-${episodeId}`;
            rewardChartContainer.innerHTML = `<canvas id="${rewardCanvasId}"></canvas>`;
            episodeContainer.appendChild(rewardChartContainer);
            
            // Steps Table
            const tableContainer = document.createElement('div');
            tableContainer.innerHTML = createStepsTable(data.steps_data);
            episodeContainer.appendChild(tableContainer);

            visualizationArea.appendChild(episodeContainer);


            const steps = data.steps_data;
            const labels = steps.map(step => step.step_in_episode);
            const capital = steps.map(step => step.capital_after_step);
            const rewards = steps.map(step => step.reward);
            const prices = steps.map(step => step.current_price_for_decision);
            const cumulativeRewards = rewards.reduce((acc, val) => { acc.push((acc.length > 0 ? acc[acc.length - 1] : 0) + val); return acc; }, []);

            // Normalize price and capital to start at the same point for scaling
            let normPrices = prices.slice();
            let normCapital = capital.slice();
            const validPrices = prices.filter(p => typeof p === 'number');
            const validCapital = capital.filter(c => typeof c === 'number');
            if (validPrices.length > 0 && validCapital.length > 0) {
                const price0 = prices.find(p => typeof p === 'number');
                const capital0 = capital.find(c => typeof c === 'number');
                if (typeof price0 === 'number' && typeof capital0 === 'number') {
                    // Both start at the same value (capital0)
                    normPrices = prices.map(p => (typeof p === 'number' ? (p / price0) * capital0 : null));
                    normCapital = capital.map(c => (typeof c === 'number' ? c : null));
                }
            }

            // Create Combined Price and Capital Chart
            if (chartObjects[priceCapitalCanvasId]) chartObjects[priceCapitalCanvasId].destroy();
            if (validPrices.length > 0 || validCapital.length > 0) {
                const datasets = [];
                if (validPrices.length > 0) {
                    datasets.push({
                        label: 'Price (Decision Point, Normalized)',
                        data: normPrices,
                        borderColor: 'rgb(153, 102, 255)',
                        backgroundColor: 'rgba(153, 102, 255, 0.5)',
                        tension: 0.1,
                        yAxisID: 'y', // Use single y-axis
                    });
                }
                if (validCapital.length > 0) {
                    datasets.push({
                        label: 'Capital Over Time',
                        data: normCapital,
                        borderColor: 'rgb(75, 192, 192)',
                        tension: 0.1,
                        yAxisID: 'y', // Use single y-axis
                    });
                }

                chartObjects[priceCapitalCanvasId] = new Chart(document.getElementById(priceCapitalCanvasId).getContext('2d'), {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: { // Single Y-axis for both
                                type: 'linear',
                                display: true,
                                position: 'left',
                                beginAtZero: false,
                                title: { display: true, text: 'Price & Capital (Normalized to Start)'},
                                ticks: { callback: function(value) { return '$' + value.toFixed(2); } }
                            },
                            x: {
                                title: { display: true, text: 'Step'}
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: 'Price and Capital Over Time (Starting at Same Point)'
                            },
                            legend: {
                                display: true
                            },
                            zoom: {
                                pan: {
                                    enabled: true,
                                    mode: 'x',
                                    threshold: 5, // Minimum pan distance in pixels
                                },
                                zoom: {
                                    wheel: {
                                        enabled: true,
                                    },
                                    drag: {
                                        enabled: true, // Enable drag-to-zoom
                                        backgroundColor: 'rgba(0,123,255,0.2)', // Optional: color of the drag selection box
                                    },
                                    pinch: {
                                        enabled: true // Enable pinch zoom for touch devices
                                    },
                                    mode: 'x', // Zoom only along the x-axis
                                }
                            }
                        }
                    }
                });
            } else {
                document.getElementById(priceCapitalCanvasId).parentElement.innerHTML += '<p>Price and/or Capital data not available or invalid.</p>';
            }

            if (chartObjects[rewardCanvasId]) chartObjects[rewardCanvasId].destroy();
            chartObjects[rewardCanvasId] = new Chart(document.getElementById(rewardCanvasId).getContext('2d'), {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Reward Per Step',
                            data: rewards,
                            backgroundColor: 'rgba(255, 99, 132, 0.5)',
                            borderColor: 'rgb(255, 99, 132)',
                            yAxisID: 'y',
                        },
                        {
                            label: 'Cumulative Reward',
                            data: cumulativeRewards,
                            borderColor: 'rgb(54, 162, 235)',
                            type: 'line',
                            tension: 0.1,
                            yAxisID: 'y1',
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: { display: true, text: 'Reward'}
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: { display: true, text: 'Cumulative Reward'},
                            grid: { drawOnChartArea: false }
                        }
                    }
                }
            });

            // Trades Table
            const tradesTableContainer = document.createElement('div');
            tradesTableContainer.classList.add('chart-container');
            tradesTableContainer.innerHTML = '<h3>Trade Log</h3>';
            const table = document.createElement('table');
            table.innerHTML = `
                <thead>
                    <tr>
                        <th>Step</th>
                        <th>Timestamp</th>
                        <th>Action</th>
                        <th>Capital</th>
                        <th>Position</th>
                        <th>Entry Price</th>
                        <th>Holding Period</th>
                        <th>Realized PnL</th>
                        <th>Unrealized PnL</th>
                        <th>Trade Units</th>
                    </tr>
                </thead>
                <tbody>
                </tbody>`;
            const tbody = table.querySelector('tbody');
            // Robust timestamp converter
            function formatTimestamp(ts) {
                if (typeof ts === 'number') {
                    // If in seconds, convert to ms
                    if (ts < 1e12) ts = ts * 1000;
                    const d = new Date(ts);
                    if (!isNaN(d.getTime())) return d.toLocaleString();
                } else if (typeof ts === 'string') {
                    // Try parsing as ISO or other string
                    let d = new Date(ts);
                    if (!isNaN(d.getTime())) return d.toLocaleString();
                    // Try parsing as number string
                    const num = Number(ts);
                    if (!isNaN(num)) {
                        if (num < 1e12) d = new Date(num * 1000);
                        else d = new Date(num);
                        if (!isNaN(d.getTime())) return d.toLocaleString();
                    }
                }
                return ts; // fallback: show raw value
            }
            steps.forEach(step => {
                const row = tbody.insertRow();
                row.insertCell().textContent = step.step_in_episode;
                row.insertCell().textContent = formatTimestamp(step.data_timestamp);
                const actionCell = row.insertCell();
                actionCell.textContent = step.action_str;
                actionCell.classList.add(`action-${step.action_str.toLowerCase()}`);
                row.insertCell().textContent = '$' + step.capital_after_step.toFixed(2);
                row.insertCell().textContent = step.position_after_step;
                row.insertCell().textContent = step.entry_price_if_in_position > 0 ? '$' + step.entry_price_if_in_position.toFixed(2) : 'N/A';
                row.insertCell().textContent = step.holding_period_after_step;
                row.insertCell().textContent = '$' + step.realized_pnl_this_step.toFixed(2);
                row.insertCell().textContent = '$' + step.unrealized_pnl_at_step_end.toFixed(2);
                row.insertCell().textContent = step.trade_units.toFixed(4);
            });
            tradesTableContainer.appendChild(table);
            episodeContainer.appendChild(tradesTableContainer);
        }
        
        function createStepsTable(steps) {
            if (!steps || steps.length === 0) return '<p>No step data available.</p>';

            let tableHtml = '<h3>Steps Details</h3><table><thead><tr>' +
                '<th>Step</th>' +
                '<th>Timestamp</th>' +
                '<th>Price (Decision)</th>' +
                '<th>Action</th>' +
                '<th>Reward</th>' +
                '<th>Capital</th>' +
                '<th>Position Before</th>' +
                '<th>Position After</th>' +
                '<th>Holding Period</th>' +
                '<th>Realized PnL</th>' +
                '<th>Unrealized PnL</th>' +
                '<th>Entry Price</th>' +
                '<th>Trade Units</th>' +
                '</tr></thead><tbody>';

            steps.forEach(step => {
                tableHtml += '<tr>' +
                    `<td>${step.step_in_episode}</td>` +
                    `<td>${step.data_timestamp ? new Date(step.data_timestamp).toLocaleString() : 'N/A'}</td>` +
                    `<td>${step.current_price_for_decision !== undefined ? step.current_price_for_decision.toFixed(2) : 'N/A'}</td>` +
                    `<td class="action-${step.action_str ? step.action_str.toLowerCase() : 'unknown'}">${step.action_str || 'N/A'} (${step.action_int})</td>` +
                    `<td>${step.reward !== undefined ? step.reward.toFixed(4) : 'N/A'}</td>` +
                    `<td>${step.capital_after_step !== undefined ? step.capital_after_step.toFixed(2) : 'N/A'}</td>` +
                    `<td>${step.position_before_action || 'N/A'}</td>` +
                    `<td>${step.position_after_step || 'N/A'}</td>` +
                    `<td>${step.holding_period_after_step !== undefined ? step.holding_period_after_step : 'N/A'}</td>` +
                    `<td>${step.realized_pnl_this_step !== undefined ? step.realized_pnl_this_step.toFixed(2) : 'N/A'}</td>` +
                    `<td>${step.unrealized_pnl_at_step_end !== undefined ? step.unrealized_pnl_at_step_end.toFixed(2) : 'N/A'}</td>` +
                    `<td>${step.entry_price_if_in_position !== undefined ? step.entry_price_if_in_position.toFixed(2) : 'N/A'}</td>` +
                    `<td>${step.trade_units !== undefined ? step.trade_units.toFixed(4) : 'N/A'}</td>` +
                    '</tr>';
            });

            tableHtml += '</tbody></table>';
            return tableHtml;
        }

        function formatKey(key) {
            return key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        }

    </script>
</body>
</html>
