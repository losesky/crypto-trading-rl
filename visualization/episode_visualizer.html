<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RL Trading Episode Visualizer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }
        h1, h2 { text-align: center; color: #333; }
        #controls { margin-bottom: 20px; text-align: center; padding: 10px; background-color: #fff; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        #fileInput { padding: 8px; margin-right: 10px; border: 1px solid #ddd; border-radius: 4px; }
        .chart-container { width: 95%; max-width: 1000px; margin: 30px auto; padding: 25px; background-color: #fff; border-radius: 8px; box-shadow: 0 0 12px rgba(0,0,0,0.1); }
        canvas { display: block; margin: 0 auto; }
        #episodeInfo { margin-top: 20px; padding: 15px; background-color: #e9e9e9; border-radius: 8px; }
        #episodeInfo p { margin: 5px 0; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #e9e9e9; }
        .action-long { color: green; }
        .action-short { color: red; }
        .action-hold { color: orange; }
    </style>
</head>
<body>
    <h1>RL Trading Episode Visualizer</h1>

    <div id="controls">
        <label for="fileInput">Select Episode JSON file(s):</label>
        <input type="file" id="fileInput" accept=".json" multiple onchange="handleFiles(this.files)">
    </div>

    <div id="visualizationArea">
        <!-- Charts and tables will be dynamically added here -->
    </div>

    <script>
        let chartObjects = {}; // To keep track of Chart.js instances

        function handleFiles(files) {
            const visualizationArea = document.getElementById('visualizationArea');
            visualizationArea.innerHTML = ''; // Clear previous visualizations
            for (const file of files) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const episodeData = JSON.parse(event.target.result);
                        displayEpisodeData(episodeData, file.name);
                    } catch (e) {
                        console.error("Error parsing JSON from file:" + file.name, e);
                        visualizationArea.innerHTML += `<p>Error loading ${file.name}: Invalid JSON format.</p>`;
                    }
                };
                reader.readAsText(file);
            }
        }

        function displayEpisodeData(data, fileName) {
            const visualizationArea = document.getElementById('visualizationArea');
            const episodeId = `episode-${fileName.replace(/[^a-zA-Z0-9]/g, '-')}`; // Create a unique ID for the episode container

            const episodeContainer = document.createElement('div');
            episodeContainer.id = episodeId;
            episodeContainer.classList.add('episode-visualization');
            episodeContainer.innerHTML = `<h2>Episode: ${fileName} (Number: ${data.episode_number})</h2>`;
            
            // Display Episode Summary
            if (data.summary) {
                const summaryDiv = document.createElement('div');
                summaryDiv.id = `summary-${episodeId}`;
                summaryDiv.classList.add('episodeInfo');
                summaryDiv.innerHTML = '<h3>Episode Summary</h3>';
                for(const key in data.summary){
                    summaryDiv.innerHTML += `<p><strong>${formatKey(key)}:</strong> ${data.summary[key]}</p>`;
                }
                episodeContainer.appendChild(summaryDiv);
            }

            // Price Chart
            const priceChartContainer = document.createElement('div');
            priceChartContainer.classList.add('chart-container');
            const priceCanvasId = `priceChart-${episodeId}`;
            priceChartContainer.innerHTML = `<canvas id="${priceCanvasId}"></canvas>`;
            episodeContainer.appendChild(priceChartContainer);

            // Capital Chart
            const capitalChartContainer = document.createElement('div');
            capitalChartContainer.classList.add('chart-container');
            const capitalCanvasId = `capitalChart-${episodeId}`;
            capitalChartContainer.innerHTML = `<canvas id="${capitalCanvasId}"></canvas>`;
            episodeContainer.appendChild(capitalChartContainer);

            // Reward Chart
            const rewardChartContainer = document.createElement('div');
            rewardChartContainer.classList.add('chart-container');
            const rewardCanvasId = `rewardChart-${episodeId}`;
            rewardChartContainer.innerHTML = `<canvas id="${rewardCanvasId}"></canvas>`;
            episodeContainer.appendChild(rewardChartContainer);
            
            visualizationArea.appendChild(episodeContainer);


            const steps = data.steps_data;
            const labels = steps.map(step => step.step_in_episode);
            const capital = steps.map(step => step.capital_after_step);
            const rewards = steps.map(step => step.reward);
            const prices = steps.map(step => step.current_price_for_decision);
            const cumulativeRewards = rewards.reduce((acc, val) => { acc.push((acc.length > 0 ? acc[acc.length - 1] : 0) + val); return acc; }, []);

            // Create Price Chart
            if (chartObjects[priceCanvasId]) chartObjects[priceCanvasId].destroy();
            const validPrices = prices.filter(p => typeof p === 'number');
            if (validPrices.length > 0) {
                chartObjects[priceCanvasId] = new Chart(document.getElementById(priceCanvasId).getContext('2d'), {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Price (Decision Point)',
                            data: prices,
                            borderColor: 'rgb(153, 102, 255)',
                            backgroundColor: 'rgba(153, 102, 255, 0.5)',
                            tension: 0.1
                        }]
                    },
                    options: {
                        scales: {
                            y: {
                                beginAtZero: false,
                                title: { display: true, text: 'Price'},
                                ticks: { callback: function(value) { return '$' + value.toFixed(2); } }
                            },
                            x: {
                                title: { display: true, text: 'Step'}
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: 'Price Over Time'
                            }
                        }
                    }
                });
            } else {
                document.getElementById(priceCanvasId).parentElement.innerHTML += '<p>Price data for decision points not available or invalid in the selected JSON file. Ensure `current_price_for_decision` is logged in `steps_data`.</p>';
            }

            if (chartObjects[capitalCanvasId]) chartObjects[capitalCanvasId].destroy();
            chartObjects[capitalCanvasId] = new Chart(document.getElementById(capitalCanvasId).getContext('2d'), {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Capital Over Time',
                        data: capital,
                        borderColor: 'rgb(75, 192, 192)',
                        tension: 0.1
                    }]
                },
                options: { scales: { y: { beginAtZero: false, ticks: { callback: function(value) { return '$' + value; } } } } }
            });

            if (chartObjects[rewardCanvasId]) chartObjects[rewardCanvasId].destroy();
            chartObjects[rewardCanvasId] = new Chart(document.getElementById(rewardCanvasId).getContext('2d'), {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Reward Per Step',
                            data: rewards,
                            backgroundColor: 'rgba(255, 99, 132, 0.5)',
                            borderColor: 'rgb(255, 99, 132)',
                            yAxisID: 'y',
                        },
                        {
                            label: 'Cumulative Reward',
                            data: cumulativeRewards,
                            borderColor: 'rgb(54, 162, 235)',
                            type: 'line',
                            tension: 0.1,
                            yAxisID: 'y1',
                        }
                    ]
                },
                options: {
                    scales: {
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: { display: true, text: 'Reward'}
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: { display: true, text: 'Cumulative Reward'},
                            grid: { drawOnChartArea: false }
                        }
                    }
                }
            });

            // Trades Table
            const tradesTableContainer = document.createElement('div');
            tradesTableContainer.classList.add('chart-container');
            tradesTableContainer.innerHTML = '<h3>Trade Log</h3>';
            const table = document.createElement('table');
            table.innerHTML = `
                <thead>
                    <tr>
                        <th>Step</th>
                        <th>Timestamp</th>
                        <th>Action</th>
                        <th>Capital</th>
                        <th>Position</th>
                        <th>Entry Price</th>
                        <th>Holding Period</th>
                        <th>Realized PnL</th>
                        <th>Unrealized PnL</th>
                        <th>Trade Units</th>
                    </tr>
                </thead>
                <tbody>
                </tbody>`;
            const tbody = table.querySelector('tbody');
            steps.forEach(step => {
                const row = tbody.insertRow();
                row.insertCell().textContent = step.step_in_episode;
                row.insertCell().textContent = new Date(step.data_timestamp).toLocaleString();
                const actionCell = row.insertCell();
                actionCell.textContent = step.action_str;
                actionCell.classList.add(`action-${step.action_str.toLowerCase()}`);
                row.insertCell().textContent = '$' + step.capital_after_step.toFixed(2);
                row.insertCell().textContent = step.position_after_step;
                row.insertCell().textContent = step.entry_price_if_in_position > 0 ? '$' + step.entry_price_if_in_position.toFixed(2) : 'N/A';
                row.insertCell().textContent = step.holding_period_after_step;
                row.insertCell().textContent = '$' + step.realized_pnl_this_step.toFixed(2);
                row.insertCell().textContent = '$' + step.unrealized_pnl_at_step_end.toFixed(2);
                row.insertCell().textContent = step.trade_units.toFixed(4);
            });
            tradesTableContainer.appendChild(table);
            episodeContainer.appendChild(tradesTableContainer);
        }
        
        function formatKey(key) {
            return key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        }

    </script>
</body>
</html>
